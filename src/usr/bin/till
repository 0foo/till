#!/usr/bin/env bash
# till — tiny per-project Debian environments (CHROOT edition: mmdebstrap + real chroot)
# - till build   : bootstrap a Debian rootfs (requires sudo)
# - till enter   : enter the rootfs; bind-mount $PWD (optional)
#                  by default uses a private mount namespace so EVERYTHING
#                  unmounts automatically when you exit the shell
# - till destroy : unmount everything under the rootfs and delete it
#
# Config precedence (highest first):
#   ./.till/config, ./.tillrc, ~/.config/till/config, /etc/till/config
#
# Config keys:
#   PATH=<path>                    # rootfs dir (default: $PWD/.till/debian)
#   RELEASE=<codename>             # default: bookworm
#   MIRROR=<url>                   # default: http://deb.debian.org/debian
#   PACKAGES_MODE=append|replace   # default: append to built-ins
#   PACKAGES="space sep list"
#   PACKAGES_FILE=<file with one pkg per line>
#   GPG_SECURE=true|false          # true=enforce sig verification; false=allow insecure
#   IPV4_ONLY=true|false           # true=force IPv4 (apt); default false
#   MOUNT_NAMESPACE=true|false     # true=use unshare -m (auto cleanup); default true
#
# Flags / env:
#   --verbose or TILL_VERBOSE=1
#   --no-bind-pwd (enter)  # do not bind the current working directory
#   --as-root (enter)      # enter as root (default: your uid/gid)
#   --no-ns (enter)        # disable mount namespace (use legacy+trap cleanup)
#   TILL_KEYRING=/path/to/keyring.gpg (optional) when GPG_SECURE=true
#
# Requires (Debian/Ubuntu): mmdebstrap, bash ≥5, coreutils, util-linux, mount
# This script uses sudo for privileged operations.

set -euo pipefail

# ---------- Pretty logging ----------
_is_tty() { [[ -t 1 ]]; }
_ts() { date +"%Y-%m-%d %H:%M:%S"; }

if _is_tty; then
  c_bold=$'\e[1m'; c_dim=$'\e[2m'; c_red=$'\e[31m'; c_yel=$'\e[33m'; c_grn=$'\e[32m'; c_cyan=$'\e[36m'; c_rst=$'\e[0m'
else
  c_bold=; c_dim=; c_red=; c_yel=; c_grn=; c_cyan=; c_rst=
fi

info()  { echo "${c_cyan}[$(_ts)] [i]${c_rst} $*"; }
warn()  { echo "${c_yel}[$(_ts)] [!]${c_rst} $*"; }
err()   { echo "${c_red}[$(_ts)] [x]${c_rst} $*" >&2; }
ok()    { echo "${c_grn}[$(_ts)] [✓]${c_rst} $*"; }
step()  { echo; echo "${c_bold}── $* ──${c_rst}"; }
_show_cmd() { printf "%s\n" "${c_dim}\$ $*${c_rst}"; }

# ---------- Defaults ----------
TILL_PATH_DEFAULT="${TILL_PATH_DEFAULT:-$PWD/.till/debian}"
TILL_RELEASE_DEFAULT="${TILL_RELEASE_DEFAULT:-bookworm}"
TILL_MIRROR_DEFAULT="${TILL_MIRROR_DEFAULT:-http://deb.debian.org/debian}"
TILL_VERBOSE="${TILL_VERBOSE:-0}"
TILL_KEYRING="${TILL_KEYRING:-}"

COMMON_PKGS_DEFAULT=(bash coreutils findutils grep sed gawk tar gzip bzip2 xz-utils less ca-certificates curl wget iputils-ping procps nano vim-tiny unzip zip sudo)

# ---------- Config ----------
TILL_CONFIG_PROJECT_1="$PWD/.till/config"
TILL_CONFIG_PROJECT_2="$PWD/.tillrc"
TILL_CONFIG_USER="$HOME/.config/till/config"
TILL_CONFIG_SYSTEM="/etc/till/config"

CFG_PATH=""; CFG_RELEASE=""; CFG_MIRROR=""; CFG_PACKAGES_MODE=""; CFG_PACKAGES=""; CFG_PACKAGES_FILE=""
CFG_GPG_SECURE=""; CFG_IPV4_ONLY=""; CFG_MOUNT_NAMESPACE=""

_read_kv_file() {
  local f="$1"
  [[ -f "$f" ]] || return 0
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    if [[ "$line" =~ ^([A-Z_]+)=(.*)$ ]]; then
      local k="${BASH_REMATCH[1]}"; local v="${BASH_REMATCH[2]}"
      v="${v%\"}"; v="${v#\"}"; v="${v%\'}"; v="${v#\'}"
      case "$k" in
        PATH)               CFG_PATH="$v" ;;
        RELEASE)            CFG_RELEASE="$v" ;;
        MIRROR)             CFG_MIRROR="$v" ;;
        PACKAGES_MODE)      CFG_PACKAGES_MODE="$v" ;;
        PACKAGES)           CFG_PACKAGES="$v" ;;
        PACKAGES_FILE)      CFG_PACKAGES_FILE="$v" ;;
        GPG_SECURE)         CFG_GPG_SECURE="$v" ;;
        IPV4_ONLY)          CFG_IPV4_ONLY="$v" ;;
        MOUNT_NAMESPACE)    CFG_MOUNT_NAMESPACE="$v" ;;
      esac
    fi
  done < "$f"
}

_load_config() {
  _read_kv_file "$TILL_CONFIG_SYSTEM"
  _read_kv_file "$TILL_CONFIG_USER"
  _read_kv_file "$TILL_CONFIG_PROJECT_2"
  _read_kv_file "$TILL_CONFIG_PROJECT_1"
}

_bool_norm() {
  case "${1,,}" in
    1|true|yes|y|on)  echo "true" ;;
    0|false|no|n|off) echo "false" ;;
    *)                echo "" ;;
  esac
}

_need() { command -v "$1" >/dev/null 2>&1 || { err "Missing tool: $1"; exit 127; }; }

_probe_mirror() {
  local url="$1" rel="$2"
  if command -v curl >/dev/null 2>&1; then
    info "Probing mirror (curl): $url/dists/$rel/InRelease"
    curl -sS -I --max-time 8 "$url/dists/$rel/InRelease" | head -n 1 || true
  elif command -v wget >/dev/null 2>&1; then
    info "Probing mirror (wget): $url/dists/$rel/InRelease"
    wget -q --spider "$url/dists/$rel/InRelease" && echo "HTTP OK" || echo "Probe failed"
  else
    warn "curl/wget not installed; skipping probe"
  fi
}

# ---------- Privilege helper ----------
sudo_exec() {
  if [[ $EUID -ne 0 ]]; then
    exec sudo --preserve-env=TILL_KEYRING,TILL_VERBOSE,PATH,PWD "$0" "$subcmd" "$@"
  fi
}

# ---------- Unmount helper (legacy path & destroy) ----------
_unmount_all() {
  local ROOT="$1"
  if mountpoint -q "$ROOT$PWD"; then umount -l "$ROOT$PWD" || true; fi
  for m in "$ROOT/dev/pts" "$ROOT/dev" "$ROOT/sys" "$ROOT/proc" "$ROOT/tmp"; do
    mountpoint -q "$m" && umount -l "$m" || true
  done
  grep " $ROOT" /proc/mounts | awk '{print $2}' | sort -r | while read -r mp; do
    umount -l "$mp" || true
  done
}

# ---------- USAGE ----------
usage() {
  cat <<EOF
till — tiny Debian environments (mmdebstrap + real chroot)
Usage:
  till build   [--path PATH] [--release REL] [--mirror URL]
               [--packages "p1 p2 ..."] [--packages-file FILE]
               [--packages-mode append|replace] [--verbose]

  till enter   [--path PATH] [--no-bind-pwd] [--as-root] [--no-ns] [--verbose]
               (default uses a private mount namespace for auto-unmount on exit)

  till destroy [--path PATH] [--force]   # unmount and delete the environment
EOF
}

# ---------- BUILD ----------
cmd_build() {
  sudo_exec "$@"

  local PATH_DIR="${TILL_PATH_DEFAULT}" REL="${TILL_RELEASE_DEFAULT}" MIR="${TILL_MIRROR_DEFAULT}" PKG_MODE="append"
  local -a PKGS=("${COMMON_PKGS_DEFAULT[@]}") INCLUDE=() MM_OPTS=() APT_OPTS=()

  [[ -n "$CFG_PATH" ]] && PATH_DIR="$CFG_PATH"
  [[ -n "$CFG_RELEASE" ]] && REL="$CFG_RELEASE"
  [[ -n "$CFG_MIRROR" ]] && MIR="$CFG_MIRROR"
  [[ -n "$CFG_PACKAGES_MODE" ]] && PKG_MODE="$CFG_PACKAGES_MODE"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path) PATH_DIR="$2"; shift 2 ;;
      --release) REL="$2"; shift 2 ;;
      --mirror) MIR="$2"; shift 2 ;;
      --packages) PKGS=(); read -r -a PKGS <<<"$2"; shift 2 ;;
      --packages-file) mapfile -t PKGS < <(grep -v '^[[:space:]]*#' "$2" | sed '/^[[:space:]]*$/d'); shift 2 ;;
      --packages-mode) PKG_MODE="$2"; shift 2 ;;
      --verbose) TILL_VERBOSE=1; shift ;;
      *) err "Unknown flag: $1"; usage; exit 2 ;;
    esac
  done

  step "Preflight"
  _need mmdebstrap; _need chroot; _need mount
  info "mmdebstrap: $(mmdebstrap --version 2>/dev/null | head -n1 || echo '?')"
  [[ "${TILL_VERBOSE:-0}" == "1" ]] && { MM_OPTS+=(--verbose); info "Verbose mode ON"; }

  # Policies
  local GPGSEC="$(_bool_norm "${CFG_GPG_SECURE:-}")"
  local IPV4="$(_bool_norm "${CFG_IPV4_ONLY:-}")"

  if [[ "$GPGSEC" == "true" ]]; then
    info "GPG_SECURE=true — enforcing signature verification"
    [[ -n "$TILL_KEYRING" && -f "$TILL_KEYRING" ]] && MM_OPTS+=(--keyring "$TILL_KEYRING")
  else
    info "GPG_SECURE=false — allowing insecure bootstrap"
    APT_OPTS+=(--aptopt='Acquire::AllowInsecureRepositories "true";')
    APT_OPTS+=(--aptopt='APT::Get::AllowUnauthenticated "true";')
  fi

  if [[ "$IPV4" == "true" ]]; then
    info "IPV4_ONLY=true — forcing IPv4"
    APT_OPTS+=(--aptopt='Acquire::ForceIPv4 "true";')
  else
    info "IPV4_ONLY=false — using system default IPv4/IPv6"
  fi

  # Extra packages
  if [[ -n "${CFG_PACKAGES:-}" ]]; then read -r -a INCLUDE <<<"${CFG_PACKAGES}"; fi
  if [[ -n "${CFG_PACKAGES_FILE:-}" && -f "${CFG_PACKAGES_FILE}" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
      INCLUDE+=("$line")
    done < "$CFG_PACKAGES_FILE"
  fi
  if [[ "${#INCLUDE[@]}" -gt 0 ]]; then
    if [[ "$PKG_MODE" == "replace" ]]; then
      PKGS=("${INCLUDE[@]}")
    else
      PKGS+=("${INCLUDE[@]}")
    fi
  fi

  step "Resolved configuration"
  info "Rootfs path : $PATH_DIR"
  info "Release     : $REL"
  info "Mirror      : $MIR"
  info "Packages    : ${PKGS[*]:-<none>}"
  [[ -n "$TILL_KEYRING" ]] && info "Keyring     : $TILL_KEYRING"
  _probe_mirror "$MIR" "$REL"

  step "Bootstrapping rootfs (mmdebstrap --mode=root)"
  mkdir -p "$PATH_DIR"
  MM_OPTS+=(--mode=root --variant=minbase --components=main,contrib,non-free-firmware)
  MM_OPTS+=(--include "$(IFS=,; echo "${PKGS[*]}")")
  APT_OPTS+=(--aptopt='Dpkg::Use-Pty "0";' --aptopt='Acquire::Retries "3";')

  _show_cmd DEBIAN_FRONTEND=noninteractive mmdebstrap "${MM_OPTS[@]}" "${APT_OPTS[@]}" "$REL" "$PATH_DIR" "$MIR"
  DEBIAN_FRONTEND=noninteractive \
  mmdebstrap "${MM_OPTS[@]}" "${APT_OPTS[@]}" "$REL" "$PATH_DIR" "$MIR"

  # Prevent services from starting inside the chroot on future apt installs
  mkdir -p "$PATH_DIR/usr/sbin"
  cat > "$PATH_DIR/usr/sbin/policy-rc.d" <<'EOF'
#!/bin/sh
exit 101
EOF
  chmod +x "$PATH_DIR/usr/sbin/policy-rc.d"

  ok "Build complete at $PATH_DIR"
}

# ---------- ENTER helpers ----------
_enter_legacy() {
  # Legacy path with real mounts + trap cleanup
  local PATH_DIR="$1" BIND_PWD="$2" AS_ROOT="$3"

  step "Preparing chroot (legacy mounts)"
  [[ -f "$PATH_DIR/etc/debian_version" ]] || { err "$PATH_DIR is not a Debian rootfs. Run 'till build'."; exit 1; }
  _need chroot; _need mount

  mkdir -p "$PATH_DIR/proc" "$PATH_DIR/sys" "$PATH_DIR/dev" "$PATH_DIR/dev/pts" "$PATH_DIR/tmp"
  mountpoint -q "$PATH_DIR/proc"    || mount -t proc  proc "$PATH_DIR/proc"
  mountpoint -q "$PATH_DIR/sys"     || mount -t sysfs sys  "$PATH_DIR/sys"
  mountpoint -q "$PATH_DIR/dev"     || mount --bind /dev     "$PATH_DIR/dev"
  mountpoint -q "$PATH_DIR/dev/pts" || mount --bind /dev/pts "$PATH_DIR/dev/pts"
  mountpoint -q "$PATH_DIR/tmp"     || mount --bind /tmp     "$PATH_DIR/tmp"

  local target=""
  if [[ "$BIND_PWD" -eq 1 ]]; then
    target="$PATH_DIR$PWD"
    mkdir -p "$target"
    mountpoint -q "$target" || mount --bind "$PWD" "$target"
  fi

  cleanup() {
    if [[ "$BIND_PWD" -eq 1 ]] && mountpoint -q "$target"; then umount -l "$target" || true; fi
    for m in "$PATH_DIR/dev/pts" "$PATH_DIR/dev" "$PATH_DIR/sys" "$PATH_DIR/proc" "$PATH_DIR/tmp"; do
      mountpoint -q "$m" && umount -l "$m" || true
    done
  }
  trap cleanup EXIT

  step "Entering chroot (legacy)"
  info "Rootfs path : $PATH_DIR"
  info "Bind PWD    : $([[ "$BIND_PWD" -eq 1 ]] && echo "yes ($PWD → $target)" || echo "no")"
  info "User inside : $([[ "$AS_ROOT" -eq 1 ]] && echo "root" || echo "$(id -u):$(id -g)")"

  if [[ "$AS_ROOT" -eq 1 ]]; then
    chroot "$PATH_DIR" /bin/bash -lc "cd '$PWD'; exec bash -l"
  else
    local uid gid; uid="$(id -u)"; gid="$(id -g)"
    chroot --userspec="${uid}:${gid}" "$PATH_DIR" /bin/bash -lc "cd '$PWD'; exec bash -l"
  fi
}

_enter_namespace() {
  # Namespace path: mounts live only inside the private mount namespace.
  local PATH_DIR="$1" BIND_PWD="$2" AS_ROOT="$3"

  step "Entering chroot (private mount namespace)"
  [[ -f "$PATH_DIR/etc/debian_version" ]] || { err "$PATH_DIR is not a Debian rootfs. Run 'till build'."; exit 1; }
  _need unshare; _need chroot; _need mount

  local uid gid; uid="$(id -u)"; gid="$(id -g)"
  local bind_line=""
  if [[ "$BIND_PWD" -eq 1 ]]; then
    bind_line='mkdir -p "'"$PATH_DIR$PWD"'" && mount --bind "'"$PWD"'" "'"$PATH_DIR$PWD"'"'
  fi

  # Build the chroot command (root or current user)
  local enter_cmd
  if [[ "$AS_ROOT" -eq 1 ]]; then
    enter_cmd="chroot '$PATH_DIR' /bin/bash -lc 'cd \"$PWD\"; exec bash -l'"
  else
    enter_cmd="chroot --userspec='$uid:$gid' '$PATH_DIR' /bin/bash -lc 'cd \"$PWD\"; exec bash -l'"
  fi

  # Run everything inside a private mount namespace; when the shell exits,
  # the namespace dies and all mounts evaporate automatically.
  _show_cmd unshare -m bash -lc '(mount --make-rprivate / || true); ...'
  unshare -m bash -lc "
    set -e
    mount --make-rprivate / || true
    mkdir -p '$PATH_DIR/proc' '$PATH_DIR/sys' '$PATH_DIR/dev' '$PATH_DIR/dev/pts' '$PATH_DIR/tmp'
    mount -t proc  proc  '$PATH_DIR/proc'
    mount -t sysfs sysfs '$PATH_DIR/sys'
    mount --bind /dev     '$PATH_DIR/dev'
    mount --bind /dev/pts '$PATH_DIR/dev/pts'
    mount --bind /tmp     '$PATH_DIR/tmp'
    $bind_line
    $enter_cmd
  "
  # No cleanup needed here — mounts were in the private namespace.
  ok "Exited chroot; all mounts cleaned up automatically."
}

# ---------- ENTER (uses namespace by default) ----------
cmd_enter() {
  sudo_exec "$@"

  local PATH_DIR="$TILL_PATH_DEFAULT" BIND_PWD=1 AS_ROOT=0 NO_NS=0
  [[ -n "$CFG_PATH" ]] && PATH_DIR="$CFG_PATH"

  # Default from config: MOUNT_NAMESPACE=true unless explicitly set false
  local NS_CFG="$(_bool_norm "${CFG_MOUNT_NAMESPACE:-true}")"
  local USE_NS="$([[ "$NS_CFG" == "false" ]] && echo 0 || echo 1)"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path) PATH_DIR="$2"; shift 2 ;;
      --no-bind-pwd) BIND_PWD=0; shift ;;
      --as-root) AS_ROOT=1; shift ;;
      --no-ns) NO_NS=1; shift ;;
      --verbose) TILL_VERBOSE=1; shift ;;
      *) err "Unknown flag: $1"; usage; exit 2 ;;
    esac
  done
  [[ "$NO_NS" -eq 1 ]] && USE_NS=0

  if [[ "$USE_NS" -eq 1 ]] && command -v unshare >/dev/null 2>&1; then
    _enter_namespace "$PATH_DIR" "$BIND_PWD" "$AS_ROOT"
  else
    [[ "$USE_NS" -eq 1 ]] && warn "unshare not available; falling back to legacy mounts."
    _enter_legacy "$PATH_DIR" "$BIND_PWD" "$AS_ROOT"
  fi
}

# ---------- DESTROY (unmount & delete) ----------
cmd_destroy() {
  sudo_exec "$@"

  local PATH_DIR="$TILL_PATH_DEFAULT" FORCE=0
  [[ -n "$CFG_PATH" ]] && PATH_DIR="$CFG_PATH"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path) PATH_DIR="$2"; shift 2 ;;
      --force|-f) FORCE=1; shift ;;
      --verbose) TILL_VERBOSE=1; shift ;;
      *) err "Unknown flag: $1"; usage; exit 2 ;;
    esac
  done

  [[ -d "$PATH_DIR" ]] || { warn "Nothing to delete at $PATH_DIR"; return 0; }

  step "Destroying environment"
  info "Target rootfs: $PATH_DIR"

  if [[ $FORCE -ne 1 ]]; then
    read -r -p "This will unmount and DELETE '$PATH_DIR'. Continue? [y/N] " ans
    case "${ans,,}" in y|yes) ;; *) warn "Aborted."; return 1 ;; esac
  fi

  info "Unmounting anything under $PATH_DIR…"
  _unmount_all "$PATH_DIR"

  if grep -q " $PATH_DIR" /proc/mounts; then
    warn "Some mount points under $PATH_DIR are still busy:"
    grep " $PATH_DIR" /proc/mounts | awk '{print " - " $2}'
    err "Refusing to delete while mounts remain. Close any shells/processes using this env and try again."
    exit 1
  fi

  info "Removing directory…"
  rm -rf --one-file-system -- "$PATH_DIR"
  ok "Environment deleted: $PATH_DIR"
}

# ---------- MAIN ----------
main() {
  _load_config
  subcmd="${1:-}"
  local rest=()
  if [[ $# -gt 0 ]]; then shift; rest=("$@"); fi
  case "$subcmd" in
    build)   for a in "${rest[@]}"; do [[ "$a" == "--verbose" ]] && TILL_VERBOSE=1; done; cmd_build   "${rest[@]}" ;;
    enter)   for a in "${rest[@]}"; do [[ "$a" == "--verbose" ]] && TILL_VERBOSE=1; done; cmd_enter   "${rest[@]}" ;;
    destroy) for a in "${rest[@]}"; do [[ "$a" == "--verbose" ]] && TILL_VERBOSE=1; done; cmd_destroy "${rest[@]}" ;;
    -h|--help|"") usage ;;
    *) err "Unknown subcommand: $subcmd"; usage; exit 2 ;;
  esac
}

main "$@"
